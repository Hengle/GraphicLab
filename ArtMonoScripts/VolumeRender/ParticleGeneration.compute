#pragma kernel OpticalDepthLUTGenerator
#define PI 3.141592653
#define PI2 6.283185306
#define PIHalf 1.5707963265

#define NUM_INTEGRATION_STEPS 20

float fReferenceParticleRadius;
uint4 ui4OpticalDepthLUTSIZE;
RWTexture3D<float> OpticalDepthLUT; 
Texture2D<float2> NoiseMap;
SamplerState sampler_NoiseMap
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};
inline uint4 C3ToC4(uint3 coord,uint4 size) 
{
    uint4 res;
    res.xy=coord.xy;
    res.z=coord.z / size.w;
    res.w=coord.z % size.w;
    return res;
}
inline int GetRaySphereIntersection(float3 f3ro, float3 f3rd, float3 f3center, inout float2 f2RayIsecs)
{
    float3 f3BiDir= f3ro - f3center;
    float A = dot(f3rd,f3rd);
    float B = dot(f3BiDir,f3rd) * 2;
    float C = dot(f3BiDir,f3BiDir) - fReferenceParticleRadius * fReferenceParticleRadius;
    float D = B * B - 4 * A * C;

    if(D < 0)
    {
        return 0;
    }
    else
    {
        D = sqrt(D);
        f2RayIsecs = float2(-B - D , -B + D);
        return 1;
    }
}
inline void SphereParamsToDescartesParams(float4 f4sphereCoord,inout float3 f3Pos,inout float3 f3Dir)
{
    f3Pos.y = cos(f4sphereCoord.y);
    float fBiAxis = sin(f4sphereCoord.y);
    f3Pos.x = fBiAxis * cos(f4sphereCoord.x);
    f3Pos.z = fBiAxis * sin(f4sphereCoord.x);
    f3Pos.xyz *= fReferenceParticleRadius;

    f3Dir.z = cos(f4sphereCoord.w);
    fBiAxis = sin(f4sphereCoord.w);
    f3Dir.x = fBiAxis * cos(f4sphereCoord.z);
    f3Dir.y = fBiAxis * sin(f4sphereCoord.z);
}

float SampleNoise(in float3 f3Pos)
{
    float3 f3P = floor(f3Pos);
    float3 f3F = frac(f3Pos);
    float2 uv = float2(f3P.xy+normalize(float2(5.4,19.0))*0.1);
    f3F = f3F * f3F * (3.0 - 2.0 * f3F);
    float2 f2res = 
    lerp(
    lerp(NoiseMap.SampleLevel(sampler_NoiseMap,uv,0),NoiseMap.SampleLevel(sampler_NoiseMap,uv+float2(0,0.1),0),f3F.x),
    lerp(NoiseMap.SampleLevel(sampler_NoiseMap,uv+float2(0.1,0),0),NoiseMap.SampleLevel(sampler_NoiseMap,uv+float2(0.1,0.1),0),f3F.x),
    f3F.y);   
    return lerp(f2res.x,f2res.y,f3F.z);
}

float GetRandomDensity(in float f3Pos, float fStartFreq, int iNumOctaves = 3, float fAmplitudeScale = 0.6)
{
    float fNoise = 0;
    float fAmplitude = 1;
    float fFreq = fStartFreq;
    for (int i = 0; i < iNumOctaves; ++i)
    {
        fNoise += (SampleNoise(f3Pos * fFreq) - 0.5) * fAmplitude;
        fFreq *= 1.7;
        fAmplitude *= fAmplitudeScale;
    }
    return fNoise;
}

float GetMetabolDenstiy(in float r)
{
    float r2 = r * r;
    float r4 = r2 * r2;
    float r6 = r4 * r2;
    return saturate(-4.0 / 9.0 * r6 + 17.0 / 9.0 * r4 - 22.0 / 9.0 *r2 + 1);
}

float ComputeDensity(float3 f3CurrPos)
{
    float fDistToCenter = length(f3CurrPos);
    float fMetabolDensity = GetMetabolDenstiy(fDistToCenter);
    float fDensity = 0;
    fDensity = saturate(1.0 * saturate(fMetabolDensity) + sqrt(fMetabolDensity)*GetRandomDensity(f3CurrPos + 0.5, 0.15, 4, 0.7));
    return fDensity;
}


[numthreads(1,1,1)]
void OpticalDepthLUTGenerator(uint3 ui3id:SV_GROUPTHREADID)
{
    uint4 ui4coord = C3ToC4(ui3id,ui4OpticalDepthLUTSIZE);
    float4 f4stepAngle = float4(PI2,PI,PI2,PIHalf) / ui4OpticalDepthLUTSIZE;
    float4 f4SphereFieldCoord = f4stepAngle * ui4coord;
    float3 f3StartPos,f3RayDir;
    SphereParamsToDescartesParams(f4SphereFieldCoord, f3StartPos, f3RayDir);
    float2 f2RayIsecs;
    GetRaySphereIntersection(f3StartPos+1e-4, f3RayDir, 0, f2RayIsecs);
    float3 f3EndPos = f3StartPos + f2RayIsecs.y * f3RayDir;
    float fNumSteps = NUM_INTEGRATION_STEPS;
    float3 f3Step = (f3EndPos - f3StartPos) / fNumSteps;
    float fTotalDensity = 0;
    for(float fStepNum = 0.5; fStepNum < fNumSteps; ++ fStepNum)
    {
        float3 f3CurrPos = f3StartPos + f3Step * fStepNum;
        fTotalDensity += ComputeDensity(f3CurrPos);
    }
    OpticalDepthLUT[ui3id] = fTotalDensity / fNumSteps;
}