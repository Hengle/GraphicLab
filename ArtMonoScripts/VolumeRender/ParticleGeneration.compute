#pragma kernel OpticalDepthLUTGenerator
#pragma kernel SingleScaterringLUTGenerator
#pragma kernel MultiScaterringLUTGenerator
#define PI 3.141592653
#define PI2 6.283185306
#define PIHalf 1.5707963265

#define NUM_INTEGRATION_STEPS 20
#define NUM_ZENITH_STEPS 20
#define NUM_AZIMUTH_STEPS 20
bool bIsFirstSctr;
float fScatteringCoeff;
float fAttenuationCoeff;
float fReferenceParticleRadius;
float4 f4LUTSize, f4SingleSctrLUTSize;
RWTexture2D<float4> OpticalDepthLUT; 
RWTexture2D<float4> SingleSctrLUT; 
RWTexture2D<float4> IterateLUT;
RWTexture2D<float4> MultiSctrLUT;
Texture2D<float2> NoiseMap;
Texture2D<float> SingleSctrInput;
SamplerState sampler_NoiseMap
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};
SamplerState sampler_SingleSctrInput
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};
inline uint4 C3ToC4(uint3 coord,uint4 size) 
{
    uint4 res;
    res.xy=coord.xy;
    res.z=coord.z / size.w;
    res.w=coord.z % size.w;
    return res;
}
inline uint4 C2ToC4(uint2 coord, uint4 size)
{
    uint4 res;
    res.x = coord.x / size.y;
    res.y = coord.x % size.y;
    res.z = coord.y / size.w;
    res.w = coord.y % size.w;
    return res;
}

inline float2 F4ToF2(float4 coord, uint4 size)
{
    float2 res;
    res.x = coord.x * size.y + coord.y;
    res.y = coord.z * size.w + coord.w;
    return res/float2(size.x*size.y,size.z*size.w);
}

inline float3 SphereCoord2Vec3(float zen, float az)
{
    float y , t;
    sincos(zen, t, y);
    float x , z;
    sincos(az, z, x);
    return float3(x*t , y , z*t);
}

inline int GetRaySphereIntersection(float3 f3ro, float3 f3rd, float3 f3center, out float2 f2RayIsecs)
{
    float3 f3BiDir= f3ro - f3center;
    float A = dot(f3rd,f3rd);
    float B = dot(f3BiDir,f3rd) * 2;
    float C = dot(f3BiDir,f3BiDir) - fReferenceParticleRadius * fReferenceParticleRadius;
    float D = B * B - 4 * A * C;

    if(D < 0)
    {
        return 0;
    }
    else
    {
        D = sqrt(D);
        f2RayIsecs = float2(-B - D , -B + D) / (2 * A);
        return 1;
    }
}
inline void SphereParamsToDescartesParams(float4 f4sphereCoord,inout float3 f3Pos,inout float3 f3Dir)
{
    f3Pos.y = cos(f4sphereCoord.y);
    float fBiAxis = sin(f4sphereCoord.y);
    f3Pos.x = fBiAxis * cos(f4sphereCoord.x);
    f3Pos.z = fBiAxis * sin(f4sphereCoord.x);
    f3Pos.xyz *= fReferenceParticleRadius;

    f3Dir.z = cos(f4sphereCoord.w);
    fBiAxis = sin(f4sphereCoord.w);
    f3Dir.x = fBiAxis * cos(f4sphereCoord.z);
    f3Dir.y = fBiAxis * sin(f4sphereCoord.z);
}

float SampleNoise(in float3 f3Pos)
{
    float3 f3P = floor(f3Pos);
    float3 f3F = frac(f3Pos);
    float2 uv = float2(f3P.xy+normalize(float2(5.4,19.0))*0.1);
    f3F = f3F * f3F * (3.0 - 2.0 * f3F);
    float2 f2res = 
    lerp(
    lerp(NoiseMap.SampleLevel(sampler_NoiseMap,uv,0),NoiseMap.SampleLevel(sampler_NoiseMap,uv+float2(0,0.1),0),f3F.x),
    lerp(NoiseMap.SampleLevel(sampler_NoiseMap,uv+float2(0.1,0),0),NoiseMap.SampleLevel(sampler_NoiseMap,uv+float2(0.1,0.1),0),f3F.x),
    f3F.y);   
    return lerp(f2res.x,f2res.y,f3F.z);
}

float GetRandomDensity(in float f3Pos, float fStartFreq, int iNumOctaves = 6, float fAmplitudeScale = 0.6)
{
    float fNoise = 0;
    float fAmplitude = 1;
    float fFreq = fStartFreq;
    for (int i = 0; i < iNumOctaves; ++i)
    {
        fNoise += (SampleNoise(f3Pos * fFreq) - 0.5) * fAmplitude;
        fFreq *= 1.7;
        fAmplitude *= fAmplitudeScale;
    }
    return fNoise;
}

float GetMetabolDenstiy(in float r)
{
    float r2 = r * r;
    float r4 = r2 * r2;
    float r6 = r4 * r2;
    return saturate(-4.0 / 9.0 * r6 + 17.0 / 9.0 * r4 - 22.0 / 9.0 *r2 + 1);
}

float ComputeDensity(float3 f3CurrPos)
{
    f3CurrPos /= fReferenceParticleRadius;
    float fDistToCenter = length(f3CurrPos);
    float fMetabolDensity = GetMetabolDenstiy(fDistToCenter);
    float fDensity = 0;
    fDensity = saturate(1.0 * saturate(fMetabolDensity) + sqrt(fMetabolDensity)*GetRandomDensity(f3CurrPos + 0.5, 0.15, 4, 0.7));
    return fDistToCenter;
}

inline void ConstructTransMat(float3 f3aDir,float3 f3inlineBidir, out float3x3 f3x3mat)
{
    float3 f3z = normalize(f3aDir);
    float3 f3y = normalize(cross(f3aDir,f3inlineBidir));
    float3 f3x = normalize(cross(f3y,f3z));
    f3x3mat = float3x3(f3z,f3y,f3x);
}

inline void SctrLUTToWorldParams(float4 f4Coord, out float3 f3StartPosUSSpace, out float3 f3ViewDirUSSpace,out float3 f3LightDirUSSpace)
{
    f3LightDirUSSpace = float3(0,0,1);
    f3StartPosUSSpace = float3(0,0,0);
    sincos(f4Coord.x,f3StartPosUSSpace.z,f3StartPosUSSpace.x);
    f3StartPosUSSpace *= (f4Coord.w * fReferenceParticleRadius);                 //Scale start pos according to the distance from center

    float3 f3OriginDir = float3(0,0,0);
    float t = 0;
    sincos(f4Coord.z,t,f3OriginDir.y);
    sincos(f4Coord.y,f3OriginDir.z,f3OriginDir.x);
    f3OriginDir.xz *= t;
    // float3x3 f3x3mat;
    // ConstructTransMat(f3LightDirUSSpace, f3StartPosUSSpace, f3x3mat);

    //f3ViewDirUSSpace = mul(f3x3mat, f3OriginDir);
    f3ViewDirUSSpace = f3OriginDir;
}
inline void WorldToSctrLUTParams(float3 f3StartPosUSSpace, float3 f3ViewDirUSSpace ,out float4 f4Coord)
{
    f4Coord = float4(0,0,0,0);
    f4Coord.w = length(f3StartPosUSSpace.xz);
    f4Coord.x = atan2(f3StartPosUSSpace.z, f3StartPosUSSpace.x);
    f4Coord.z = acos(f3ViewDirUSSpace.y);
    f4Coord.y = atan2(f3ViewDirUSSpace.x, f3ViewDirUSSpace.z);
}

inline float HGPhase(float dotTheta, float g)
{
    float fTopPart  = 3*(1 - g * g) *(1 + dotTheta * dotTheta);
    float fBottomPart = 4 * PI2 * (2 + g * g) * pow((1 + g * g - 2 * g * dotTheta), 1.5);
    return fTopPart / fBottomPart;
}

[numthreads(32,32,1)]
void OpticalDepthLUTGenerator(uint2 ui2id: SV_DISPATCHTHREADID)
{
    uint4 ui4coord = C2ToC4(ui2id,floor(f4LUTSize));
    float4 f4stepAngle = float4(PI2,PI,PI2,PIHalf) / f4LUTSize;
    float4 f4SphereFieldCoord = f4stepAngle * ui4coord;
    float3 f3StartPos,f3RayDir;
    SphereParamsToDescartesParams(f4SphereFieldCoord, f3StartPos, f3RayDir);
    float2 f2RayIsecs;
    GetRaySphereIntersection(f3StartPos+1e-4, f3RayDir, 0, f2RayIsecs);
    float3 f3EndPos = f3StartPos + f2RayIsecs.y * f3RayDir;
    float fNumSteps = NUM_INTEGRATION_STEPS;
    float3 f3Step = (f3EndPos - f3StartPos) / fNumSteps;
    float fTotalDensity = 0;
    for(float fStepNum = 0.5; fStepNum < fNumSteps; ++ fStepNum)
    {
        float3 f3CurrPos = f3StartPos + f3Step * fStepNum;
        fTotalDensity += ComputeDensity(f3CurrPos);
    }
    OpticalDepthLUT[ui2id] = float4((fTotalDensity / fNumSteps),0,0,1);
    //OpticalDepthLUT[ui2id] = f4SphereFieldCoord.y/PI;
}
[numthreads(32,32,1)]
void SingleScaterringLUTGenerator(uint2 ui2id: SV_DISPATCHTHREADID)
{
    uint4 ui4coord = C2ToC4(ui2id, floor(f4SingleSctrLUTSize));
    float3 f3stepAngle = float3(PI,PI2,PI) / f4SingleSctrLUTSize.xyz;
    float3 f3SphereCoord = f3stepAngle * ui4coord.xyz;
    float3 f3EntryPoint , f3ViewDirUSSpace , f3LightDirUSSpace;
    float4 f4Coord = float4(f3SphereCoord,1);
    SctrLUTToWorldParams(f4Coord,f3EntryPoint,f3ViewDirUSSpace,f3LightDirUSSpace);

    float2 f2RayIsecs;
    GetRaySphereIntersection(f3EntryPoint,f3ViewDirUSSpace, 0,f2RayIsecs);
    float3 f3EndPos = f3EntryPoint + f3ViewDirUSSpace * f2RayIsecs.y;

    float fNumSteps = NUM_INTEGRATION_STEPS;
    float3 f3Step = (f3EndPos - f3EntryPoint) / fNumSteps;
    float fStepLen = length(f3Step);
    float fCloudMassToCamera = 0;
    float fInscattering = 0;
    for(float fStepNum = 0.5;fStepNum < fNumSteps; ++ fStepNum)
    {
        float3 f3CurrPos = f3EntryPoint + f3Step * fStepNum;
        GetRaySphereIntersection(f3CurrPos, f3LightDirUSSpace, 0,f2RayIsecs);
        float fCloudMassToLight = abs(f2RayIsecs.x) * fReferenceParticleRadius;
        float fAttenuation = exp(-fAttenuationCoeff * (fCloudMassToLight + fCloudMassToCamera) );
        fInscattering +=fAttenuation * fScatteringCoeff;
        fCloudMassToCamera += fStepLen * fReferenceParticleRadius;
    }
    SingleSctrLUT[ui2id]= float4(fInscattering * fStepLen * fReferenceParticleRadius,0,0,1);
    IterateLUT[ui2id] = float4(fInscattering * fStepLen * fReferenceParticleRadius,0,0,1);
}

[numthreads(32,32,1)]
void MultiScaterringLUTGenerator(uint2 ui2id: SV_DISPATCHTHREADID)
{
    uint4 ui4coord = C2ToC4(ui2id, floor(f4SingleSctrLUTSize));
    float3 f3stepAngle = float3(PI,PI2,PI) / f4SingleSctrLUTSize.xyz;
    float3 f3SphereCoord = f3stepAngle * ui4coord.xyz;
    float3 f3EntryPoint , f3ViewDirUSSpace , f3LightDirUSSpace;
    float4 f4Coord = float4(f3SphereCoord,1);
    SctrLUTToWorldParams(f4Coord,f3EntryPoint,f3ViewDirUSSpace,f3LightDirUSSpace);

    float fJ = 0;
    float fTotalSolidAngle = 0;
    const float fNumZenithSteps = NUM_ZENITH_STEPS;
    const float fNumAzimuthSteps = NUM_AZIMUTH_STEPS;
    const float fZenithSpan = PI;
    const float fAzimuthSpan = PI2;

    for(float zen = 0.5; zen < fNumZenithSteps; ++zen)
    {
        for(float azi = 0.5; azi < fNumAzimuthSteps; ++azi)
        {
            float fZenith = zen / fNumZenithSteps * fZenithSpan;
            float fAzimuth = (azi / fNumAzimuthSteps - 0.5) * fAzimuthSpan;
            float3 f3CurrDir = SphereCoord2Vec3(fZenith , fAzimuth);
            float4 f4CurrDirLUTCoords;
            WorldToSctrLUTParams(f3EntryPoint, f3CurrDir, f4CurrDirLUTCoords);
            float4 f4coord = float4(f4CurrDirLUTCoords.xyz /  f3stepAngle,1);
            float fCurrSctr = SingleSctrInput.SampleLevel(sampler_SingleSctrInput,F4ToF2(f4coord, f4SingleSctrLUTSize),0).x;
            if(bIsFirstSctr)
                fCurrSctr *= HGPhase(dot(-f3CurrDir, f3LightDirUSSpace) , 0.9);
            fCurrSctr *= HGPhase(dot(f3CurrDir, f3ViewDirUSSpace) , 0.7);
            float fdZenithAngle = fZenithSpan / fNumZenithSteps;
            float fdAzimuthAngle = fAzimuthSpan / fNumAzimuthSteps * sin(fZenith);
            float fDiffSolidAngle = fdZenithAngle + fdAzimuthAngle;
            fTotalSolidAngle += fDiffSolidAngle;
            fJ += fCurrSctr * fDiffSolidAngle;
        }
    }
    fJ *= 2* PI2 / fTotalSolidAngle;
    MultiSctrLUT[ui2id] = float4(fJ, 0, 0, 1);
    IterateLUT[ui2id] = float4(fJ, 0, 0, 1);
}