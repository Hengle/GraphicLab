#pragma kernel OpticalDepthLUTGenerator
#pragma kernel SingleScaterringLUTGenerator
#pragma kernel MultiScaterringLUTGenerator
#pragma kernel Tex3DTest
#define PI 3.141592653
#define PI2 6.283185306
#define PIHalf 1.5707963265

#define NUM_INTEGRATION_STEPS 20
#define NUM_ZENITH_STEPS 20
#define NUM_AZIMUTH_STEPS 20
bool bIsFirstSctr;
float fScatteringCoeff;
float fAttenuationCoeff;
float fReferenceParticleRadius;
float4 f4LUTSize, f4SingleSctrLUTSize;
RWTexture2D<float4> OpticalDepthLUT; 
RWTexture2D<float4> SingleSctrLUT; 
RWTexture2D<float4> IterateLUT;
RWTexture2D<float4> MultiSctrLUT;
Texture2D<float> SingleSctrInput;
SamplerState sampler_SingleSctrInput
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};
inline float Atan2Abs(float fy,float fx)
{
    float oR = atan2(fy,fx);
    oR = oR * step(0, oR) + step(oR, 0) * (PI2 + oR);
    return oR;
}
inline uint4 C3ToC4(uint3 coord,uint4 size) 
{
    uint4 res;
    res.xy=coord.xy;
    res.z=coord.z % size.z;
    res.w=coord.z / size.z;
    return res;
}
inline uint4 C2ToC4(uint2 coord, uint4 size)
{
    uint4 res;
    res.x = coord.x % size.x;
    res.y = coord.y / size.x;
    res.z = coord.y % size.z;
    res.w = coord.y / size.z;
    return res;
}

inline float Rand2D(float2 fInput)
{
    return frac(sin(dot(fInput, float2(12.989, 53.321))) * 43574.422534);
}

inline float PerlinRand2D(float2 fInput)
{
    float2 fp = floor(fInput);
    float2 fi = frac(fInput);
    float2 u = fi * fi * (3.0 - 2.0 * fi);
    return lerp(
        lerp(Rand2D(fInput), Rand2D(fInput + float2(1.0, 0)), u.x),
        lerp(Rand2D(fInput + float2(0, 1.0)), Rand2D(fInput + float2(1.0, 1.0)), u.x),  
        u.y
    );
}

inline float PerlinRand3D(float3 fInput)
{
    return PerlinRand2D(fInput.xy + fInput.z * normalize(float2(12.945, -78.563)));
}

inline float2 F4ToF2(float4 coord, uint4 size)
{
    float2 res;
    res.x = coord.x + size.x * coord.y;
    res.y = coord.z + size.z * coord.w;
    return res/float2(size.x * size.y, size.z * size.w);
}

inline float3 SphereCoord2Vec3(float zen, float az)
{
    float y , t;
    sincos(zen, t, y);
    float x , z;
    sincos(az, z, x);
    return float3(x*t , y , z*t);
}

inline int GetRaySphereIntersection(float3 f3ro, float3 f3rd, float3 f3center, out float2 f2RayIsecs)
{
    float3 f3BiDir= f3ro - f3center;
    float A = dot(f3rd,f3rd);
    float B = dot(f3BiDir,f3rd) * 2;
    float C = dot(f3BiDir,f3BiDir) - fReferenceParticleRadius * fReferenceParticleRadius;
    float D = B * B - 4 * A * C;

    if(D < 0)
    {
        return 0;
    }
    else
    {
        D = sqrt(D);
        f2RayIsecs = float2(-B - D , -B + D) / (2 * A);
        return 1;
    }
}
inline void SphereParamsToDescartesParams(float4 f4sphereCoord,inout float3 f3Pos,inout float3 f3Dir)
{
    f3Pos.y = cos(f4sphereCoord.y);
    float fBiAxis = sin(f4sphereCoord.y);
    f3Pos.x = fBiAxis * cos(f4sphereCoord.x);
    f3Pos.z = fBiAxis * sin(f4sphereCoord.x);
    f3Pos.xyz *= fReferenceParticleRadius;

    f3Dir.z = cos(f4sphereCoord.w);
    fBiAxis = sin(f4sphereCoord.w);
    f3Dir.x = fBiAxis * cos(f4sphereCoord.z);
    f3Dir.y = fBiAxis * sin(f4sphereCoord.z);
}


float GetRandomDensity(float3 f3Pos, float fStartFreq, int iNumOctaves, float fAmplitudeScale)
{
    float fNoise = 0;
    float fAmplitude = 1;
    float fFreq = fStartFreq;
    for (int i = 0; i < iNumOctaves; ++i)
    {
        fNoise += (PerlinRand3D(f3Pos * fFreq).r - 0.1) * fAmplitude;
        fFreq *= 1.7;
        fAmplitude *= fAmplitudeScale;
    }
    return fNoise;
}

float GetMetabolDenstiy(in float r)
{
    float r2 = r * r;
    float r4 = r2 * r2;
    float r6 = r4 * r2;
    return saturate(-4.0 / 9.0 * r6 + 17.0 / 9.0 * r4 - 22.0 / 9.0 *r2 + 1);
}

float ComputeDensity(float3 f3CurrPos)
{
    f3CurrPos /= fReferenceParticleRadius;
    float fDistToCenter = length(f3CurrPos);
    float fMetabolDensity = GetMetabolDenstiy(fDistToCenter);
    float fDensity = 0;
    // + sqrt(fMetabolDensity)*GetRandomDensity(f3CurrPos, 0.15, 1, 0.2)
    fDensity = saturate(GetRandomDensity(f3CurrPos, 0.15, 5, 0.2));
    return fDensity;
}

inline void ConstructTransMat(float3 f3aDir,float3 f3inlineBidir, out float3x3 f3x3mat)
{
    float3 f3z = normalize(f3aDir);
    float3 f3y = normalize(cross(f3aDir,f3inlineBidir));
    float3 f3x = normalize(cross(f3y,f3z));
    f3x3mat = float3x3(f3z,f3y,f3x);
}

inline void SctrLUTToWorldParams(float4 f4Coord, out float3 f3StartPosUSSpace, out float3 f3ViewDirUSSpace,out float3 f3LightDirUSSpace)
{
    f3LightDirUSSpace = float3(0,0,1);
    f3StartPosUSSpace = float3(0,0,0);
    sincos(f4Coord.x,f3StartPosUSSpace.z,f3StartPosUSSpace.x);
    f3StartPosUSSpace *= (f4Coord.w * fReferenceParticleRadius);                 //Scale start pos according to the distance from center

    float3 f3OriginDir = float3(0,0,0);
    float t = 0;
    sincos(f4Coord.y,t,f3OriginDir.y);
    sincos(f4Coord.z,f3OriginDir.z,f3OriginDir.x);
    f3OriginDir.xz *= t;
    // float3x3 f3x3mat;
    // ConstructTransMat(f3LightDirUSSpace, f3StartPosUSSpace, f3x3mat);

    //f3ViewDirUSSpace = mul(f3x3mat, f3OriginDir);
    f3ViewDirUSSpace = f3OriginDir;
}
inline void WorldToSctrLUTParams(float3 f3StartPosUSSpace, float3 f3ViewDirUSSpace ,out float4 f4Coord)
{
    f4Coord = float4(0,0,0,0);
    f4Coord.w = length(f3StartPosUSSpace.xz);
    f4Coord.x = Atan2Abs(f3StartPosUSSpace.z, f3StartPosUSSpace.x);
    f4Coord.y = acos(f3ViewDirUSSpace.y);
    f4Coord.z = Atan2Abs(f3ViewDirUSSpace.x, f3ViewDirUSSpace.z);
}

inline float HGPhase(float dotTheta, float g)
{
    float fTopPart  = 1 - g * g;
    float fBottomPart = 4 * PI2 * pow(1 + g * g - 2 * g * dotTheta , 1.5);
    return fTopPart / fBottomPart;
}

[numthreads(32,32,1)]
void OpticalDepthLUTGenerator(uint2 ui2id: SV_DISPATCHTHREADID)
{
    uint4 ui4coord = C2ToC4(ui2id, uint4(f4LUTSize));
    float4 f4stepAngle = float4(PI2,PI,PI2,PI) / f4LUTSize;
    float4 f4SphereFieldCoord = f4stepAngle * ui4coord;
    float3 f3StartPos,f3RayDir;
    SphereParamsToDescartesParams(f4SphereFieldCoord, f3StartPos, f3RayDir);
    float2 f2RayIsecs;
    GetRaySphereIntersection(f3StartPos+1e-4, f3RayDir, 0, f2RayIsecs);
    float3 f3EndPos = f3StartPos + f2RayIsecs.y * f3RayDir;
    float fNumSteps = NUM_INTEGRATION_STEPS;
    float3 f3Step = (f3EndPos - f3StartPos) / fNumSteps;
    float fTotalDensity = 0;
    for(float fStepNum = 0.5; fStepNum < fNumSteps; ++ fStepNum)
    {
        float3 f3CurrPos = f3StartPos + f3Step * fStepNum;
        fTotalDensity += ComputeDensity(f3CurrPos);
    }
    OpticalDepthLUT[ui2id] = float4((fTotalDensity / fNumSteps),0,0,1);
    //OpticalDepthLUT[ui2id] = f4SphereFieldCoord.y/PI;
}
[numthreads(32,32,1)]
void SingleScaterringLUTGenerator(uint2 ui2id: SV_DISPATCHTHREADID)
{
    uint4 ui4coord = C2ToC4(ui2id, uint4(f4LUTSize));
    float3 f3stepAngle = float3(PI,PI,PI2) / f4SingleSctrLUTSize.xyz;
    float3 f3SphereCoord = f3stepAngle * ui4coord.xyz;
    float3 f3EntryPoint , f3ViewDirUSSpace , f3LightDirUSSpace;
    float4 f4Coord = float4(f3SphereCoord,1);
    SctrLUTToWorldParams(f4Coord,f3EntryPoint,f3ViewDirUSSpace,f3LightDirUSSpace);

    float2 f2RayIsecs;
    GetRaySphereIntersection(f3EntryPoint,f3ViewDirUSSpace, 0,f2RayIsecs);
    float3 f3EndPos = f3EntryPoint + f3ViewDirUSSpace * f2RayIsecs.y;

    float fNumSteps = NUM_INTEGRATION_STEPS;
    float3 f3Step = (f3EndPos - f3EntryPoint) / fNumSteps;
    float fStepLen = length(f3Step);
    float fCloudMassToCamera = 0;
    float fInscattering = 0;
    for(float fStepNum = 0.5;fStepNum < fNumSteps; ++ fStepNum)
    {
        float3 f3CurrPos = f3EntryPoint + f3Step * fStepNum;
        GetRaySphereIntersection(f3CurrPos, f3LightDirUSSpace, 0,f2RayIsecs);
        float fCloudMassToLight = abs(f2RayIsecs.x) * fReferenceParticleRadius;
        float fAttenuation = exp(-fAttenuationCoeff * (fCloudMassToLight + fCloudMassToCamera) );
        fInscattering +=fAttenuation * fScatteringCoeff;
        fCloudMassToCamera += fStepLen * fReferenceParticleRadius;
    }
    SingleSctrLUT[ui2id]= float4(fInscattering * fStepLen * fReferenceParticleRadius,0,0,1);
    IterateLUT[ui2id] = float4(fInscattering * fStepLen * fReferenceParticleRadius,0,0,1);
}

[numthreads(32,32,1)]
void MultiScaterringLUTGenerator(uint2 ui2id: SV_DISPATCHTHREADID)
{
    uint4 ui4coord = C2ToC4(ui2id, uint4(f4LUTSize));
    float3 f3stepAngle = float3(PI,PI2,PI) / f4SingleSctrLUTSize.xyz;
    float3 f3SphereCoord = f3stepAngle * ui4coord.xyz;
    float3 f3EntryPoint , f3ViewDirUSSpace , f3LightDirUSSpace;
    float4 f4Coord = float4(f3SphereCoord,1);
    SctrLUTToWorldParams(f4Coord,f3EntryPoint,f3ViewDirUSSpace,f3LightDirUSSpace);

    float fJ = 0;
    float fTotalSolidAngle = 0;
    const float fNumZenithSteps = NUM_ZENITH_STEPS;
    const float fNumAzimuthSteps = NUM_AZIMUTH_STEPS;
    const float fZenithSpan = PI;
    const float fAzimuthSpan = PI2;

    for(float zen = 0.5; zen < fNumZenithSteps; ++zen)
    {
        for(float azi = 0.5; azi < fNumAzimuthSteps; ++azi)
        {
            float fZenith = zen / fNumZenithSteps * fZenithSpan;
            float fAzimuth = (azi / fNumAzimuthSteps - 0.5) * fAzimuthSpan;
            float3 f3CurrDir = SphereCoord2Vec3(fZenith , fAzimuth);
            float4 f4CurrDirLUTCoords;
            WorldToSctrLUTParams(f3EntryPoint, f3CurrDir, f4CurrDirLUTCoords);
            float4 f4coord = float4(f4CurrDirLUTCoords.xyz /  f3stepAngle,1);
            float fCurrSctr = SingleSctrInput.SampleLevel(sampler_SingleSctrInput,F4ToF2(f4coord, f4SingleSctrLUTSize),0).x;
            if(bIsFirstSctr)
                fCurrSctr *= HGPhase(dot(-f3CurrDir, f3LightDirUSSpace) , 0.9);
            fCurrSctr *= HGPhase(dot(f3CurrDir, f3ViewDirUSSpace) , 0.7);
            float fdZenithAngle = fZenithSpan / fNumZenithSteps;
            float fdAzimuthAngle = fAzimuthSpan / fNumAzimuthSteps * sin(fZenith);
            float fDiffSolidAngle = fdZenithAngle + fdAzimuthAngle;
            fTotalSolidAngle += fDiffSolidAngle;
            fJ += fCurrSctr * fDiffSolidAngle;
        }
    }
    fJ *= 2* PI2 / fTotalSolidAngle;
    MultiSctrLUT[ui2id] = float4(fJ, 0, 0, 1);
    IterateLUT[ui2id] = float4(fJ, 0, 0, 1);
}

RWTexture3D<float4> tex;
[numthreads(32,32,1)]
void Tex3DTest(uint3 ui3id: SV_DISPATCHTHREADID)
{
    tex[ui3id] = float4(0,1,0,1);
}